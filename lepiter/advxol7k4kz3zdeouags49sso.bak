{
	"__schema" : "4.1",
	"__type" : "page",
	"children" : {
		"__type" : "snippets",
		"items" : [
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2022-11-03T12:25:42.899+00:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2022-11-03T12:25:42.899+00:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "UFH1yvGoDQCFRp8QDgJQMw=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "in a metamath verifier unification is trivial because:\r\n(\r\n* Mandatory hypotheses must be pushed on the proof stack in the order in which they appear.\r\nIn addition, each variable must have its type specified with a $f hypothesis before it is used and that each $f hypothesis have the restricted syntax of a typecode (a constant) followed by a variable."
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2022-11-03T09:05:53.405+00:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2022-11-03T12:26:06.467+00:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "SCxUAO+oDQCU2r2hCodtrw=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "The typecode in the $f hypothesis must match the first symbol of the corresponding RPN stack entry\r\n(which will also be a constant), so the only possible match for the variable in the $f hypothesis is the sequence of symbols in the stack entry after the initial constant.\r\n)"
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2022-11-03T09:06:00.338+00:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2022-11-03T12:19:20.158+00:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "aPK9AO+oDQCU28t0Codtrw=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "to discover new proofs\r\nis non-trivial because ... ... Godel... etc. P != NP ......?"
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2022-11-03T09:06:17.858+00:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2022-11-03T09:06:17.858+00:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "AETJAe+oDQCU3FDbCodtrw=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "The general algorithm for unification described in the literature is\r\nsomewhat complex.\r\nIn the Proof Assistant, a more general unification algorithm is used.\r\n\r\nDOES MMJ use the same algo?\r\nHOW does MMJ do it?\r\n\r\nWhat is the best (description of the) algorithm? ?\r\n"
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2022-11-03T12:22:07.431+00:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2022-11-03T12:22:07.431+00:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "iIUdvvGoDQCFOkIvDgJQMw=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "GtMM currently has some tricks/features.\r\neg, you can work forwards and backwards.\r\n\r\nforwards = starting with the essential hypoths and moving from left right .\r\n\r\nbackwards = starting with the chain we want to make and moving right to left.\r\nsuppose we guess at the last machine we'll use,\r\nthen GtMM can show us what chain(s) that machine would need for its inputs"
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2022-11-03T12:22:13.869+00:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2022-11-03T12:22:13.869+00:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "+MF/vvGoDQCFOyr7DgJQMw=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "chains are strings of blobs.\r\nblobs are metamath variables.\r\ntriangular blobs are variables that can be 'mapped' to other chains.\r\nsquare blobs cannot be mapped."
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2022-11-03T12:21:58.187+00:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2022-11-03T12:22:13.87+00:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "EHyQvfGoDQCFOfuGDgJQMw=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "unification = doing the mapping? / finding it\r\n\r\n|- = provable /         starting chain  /   essential hypoths\r\n\r\nGtMM just ignores floating hypoths????\r\n\r\nchain we need to make to complete the level\r\nalways shown top-center in Gtmm\r\n\r\nessential hypoths = chains given to start with,\r\nthey are used as input for the machines.\r\nshown in top left of gtmm.\r\n\r\nmachines you can use (= things we've already proved)\r\nare shown on the right of the screen.\r\n\r\nclick on a machine to add it to the workspace pane.\r\nworkspace pane is always in the center of gtmm screen."
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2022-11-03T09:04:46.452+00:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2022-11-03T12:22:43.062+00:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "GJIV+u6oDQCU14iwCodtrw=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "##4.3.1 The Concept of Unification During the course of verifying a proof,\r\n\r\nwhen Metamath encounters an assertion label,\r\nit associates the mandatory hypotheses of the assertion\r\nwith the top entries of the RPN stack.\r\n\r\nMetamath then determines what substitutions\r\nit must make to the variables in the assertion’s mandatory hypotheses\r\nin order for these hypotheses to become identical to their\r\ncorresponding stack entries.\r\n\r\nThis process is called unification.\r\n\r\n(We also informally use the term “unification”\r\nto refer to a set of substitutions that results from the process,\r\nas in “two unifications are possible.”)\r\n\r\nAfter the substitutions are made,\r\nthe hypotheses are said to be unified.\r\n\r\nIf no such substitutions are possible,\r\nMetamath will consider the proof incorrect and notify you with an error message.\r\n\r\nWhile a proof is being developed, sometimes not enough information is\r\navailable to determine a unique unification.\r\nIn this case Metamath will ask you to pick the correct one."
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2022-11-03T12:23:17.745+00:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2022-11-03T12:23:17.745+00:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "gHFOwvGoDQCFPP01DgJQMw=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "##The principles of first order unification are not so bad. Here's a sketch of the algorithm."
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2022-11-03T12:23:21.625+00:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2022-11-03T12:23:21.625+00:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "2KGJwvGoDQCFPb5xDgJQMw=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "Let's say you want to apply a theorem like negeqd: ( ph -> A = B ) |- ( ph -> -u A = -u B ) where the current goal is |- ( X  </ \\\\ Y - > ?a = -u 3 ). Here ?a is a metavariable; mmj2 calls these \"work variables\" and writes them like &C1. They represent terms that have not yet been determined. They should be distinguished from X and Y, which are regular variables which are being held fixed for the purpose of the proof - they may as well be constants like 3. (Some sources will even call them \"local constants\" to emphasize this perspective.)"
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2022-11-03T12:23:24.261+00:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2022-11-03T12:23:24.261+00:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "uNqxwvGoDQCFPu+nDgJQMw=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "First, we instantiate all the variables in the theorem with fresh metavariables, resulting in ( ?ph -> ?A = ?B ) |- ( ?ph -> -u ?A = -u ?B ) where ?ph, ?A and ?B are new metavariables of their respective types (?ph is 'wff', ?A and ?B are 'class'). Each metavariable corresponds to a hole in the proof that we must eventually fill before generating the final proof output. (Metamath has no direct concept of metavariables / work variables, although for historical reasons the variables that metamath normally uses are sometimes also called metavariables.)"
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2022-11-03T12:23:29.207+00:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2022-11-03T12:23:29.207+00:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "CFP9wvGoDQCFP/K1DgJQMw=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "Next, we have to solve the \"unification problem\" ( ?ph -> -u ?A = -u ?B ) =?= ( X < \\Y -> ?a = -u 3 ). That is, we have two expressions, each containing metavariables, and we must come up with an assignment to the metavariables such that these two expressions come out identical. The procedure for this is as follows:"
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2022-11-03T09:08:03.327+00:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2022-11-03T12:23:29.208+00:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "6ErjB++oDQCU3X2DCodtrw=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "1. If both sides are equal, do nothing and succeed. That is, e =?= e is trivially satisfied.\r\n2. If both sides are applications of the same term constructor, unify all the arguments. That is, from f(e1, ..., en) =?= f(e1', ..., en') we get subproblems e1 =?= e1', ..., en =?= en'.\r\n3. If both sides are applications of different term constructors, fail: there is no possible resolution. (This case is more complicated if you can unfold definitions, but luckily this isn't an issue in metamath unification.)\r\n4. If one side is a metavariable and the other side is not, assign the metavariable. That is, ?m =?= e is resolved by setting ?m := e. (There is a caveat, see below.)\r\n5. If both sides are metavariables, either one can be assigned to the other one.\r\n\r\nWhen a metavariable is assigned, all occurrences of it should either be immediately replaced with the assignment, or else you have to keep track of a map of metavariable assignments and do all matching and equality testing modulo this assignment map.\r\n\r\nIn our example, it works as follows:\r\n* ( ?ph -> -u ?A = -u ?B ) =?= ( X < \\Y -> ?a = -u 3 ) is an implication on both sides, so we use rule 2 and get two subgoals\r\n  * ?ph =?= X < Y is solved by assigning ?ph := X < Y (rule 4)\r\n  * -u ?A = -u ?B =?= ?a = -u 3 has an equality on both sides, so we use rule 2 and get two subgoals\r\n    * -u ?A =?= ?a is solved by assigning ?a := -u ?A\r\n    * -u ?B =?= -u 3 is an application of -u on both sides, so use rule 2 with one subgoal\r\n      * ?B =?= 3 is solved by assigning ?B := 3\r\n\r\nAt the end, we have an assignment {?ph := X < Y, ?a := -u ?A, ?B := 3}, which give us the substitution arguments to negeqd, and also result in the instantiated hypothesis subgoal ( X <\\ Y -> ?A = 3 ), which is passed on to the user or the next step. Note that ?A was not solved by this process, and we will hopefully solve it later by more theorem applications. If after all theorems have been applied these variables are still sticking around, mmj2 will arbitrarily insert some variables to assign to the metavars, for example setting ?A := A (the literal variable A) to get rid of all the metavars and produce a valid metamath proofs. Also note that ?a was solved even though it was not a new metavariable: this will require rewriting any occurrences of ?a anywhere else in the proof with the assignment -u ?A.\r\n\r\nThe caveat mentioned in rule 4 is that we must check that metavariable assignments are not cyclic. If we have the goal ?a =?= ?a then rule 1 applies, so we don't have to assign ?a, but if the goal is ?a =?= -u ?a, then it would seem that we should use rule 4 and assign ?a := -u ?a, but this would result in an infinite expression ?a := -u -u -u -u ... which is bad. To check this, we just have to make sure when assigning a metavariable ?a := e due to rule 4 that e does not contain ?a in it. If it does, we fail, because it is impossible to solve the equation with a finite substitution in this case.\r\n\r\nThere are a variety of more complex extensions to this basic idea where you might need to delay solving constraints or combine multiple unification constraints, but the approach described here suffices for metamath unification.\r\n\r\nMario Carneiro"
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2022-12-10T10:34:30.694+00:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2022-12-10T10:34:52.798+00:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "QO79jNirDQCaBGjECIY3+w=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "##Curry-Howard correspondence isomorphism"
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2022-12-10T10:35:11.39+00:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2022-12-10T10:35:20.686+00:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "KADGjtirDQCaBoE2CIY3+w=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "Nand gates"
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2022-12-10T10:35:24.271+00:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2022-12-10T10:35:49.294+00:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "uAN3kNirDQCaCX/5CIY3+w=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "Turing machines. POST. manufactoria. lamb"
			}
		]
	},
	"createEmail" : {
		"__type" : "email",
		"emailString" : "<unknown>"
	},
	"createTime" : {
		"__type" : "time",
		"time" : {
			"__type" : "dateAndTime",
			"dateAndTimeString" : "2022-11-03T09:04:08.597+00:00"
		}
	},
	"editEmail" : {
		"__type" : "email",
		"emailString" : "<unknown>"
	},
	"editTime" : {
		"__type" : "time",
		"time" : {
			"__type" : "dateAndTime",
			"dateAndTimeString" : "2022-11-03T09:04:19.752+00:00"
		}
	},
	"pageType" : {
		"__type" : "namedPage",
		"title" : "Unification "
	},
	"uid" : {
		"__type" : "uuid",
		"uuid" : "08ee14fa-eea8-0d00-94d6-c10a0a876daf"
	}
}